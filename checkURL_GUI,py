#!/usr/bin/python3

'''
BY: UNDEADSEC from BRAZIL :)
    GUI By Retro Jack

Visit:      https://www.youtube.com/c/UndeadSec
Github:     https://github.com/UndeadSec/checkURL
Telegram:   https://t.me/UndeadSec      
'''

# Import necessary libraries
import tkinter as tk
from tkinter import messagebox, filedialog, ttk
from socket import socket, AF_INET, SOCK_STREAM, gethostbyname, gaierror
import threading

# Global variable to store the text widget for displaying results
result_text_widget = None

# Display original banner
def banner():
    msg = '''       _               _       _    _ _____  _ 
      | |             | |     | |  | |  __ \| |
   ___| |__   ___  ___| | __  | |  | | |__) | |
  / __| '_ \ / _ \/ __| |/ /  | |  | |  _  /| |
 | (__| | | |  __| (__|   <   | |__| | | \ \| |____
  \___|_| |_|\___|\___|_|\_\   \____/|_|  \_|______| 
            .. .UndeadSec from Brazil. ..
                  .. .Retro Jack. ..
    '''
    return msg

# Update the result text widget with the given message
def show_result(msg):
    global result_text_widget
    if result_text_widget:
        # Enable the text widget to modify its content
        result_text_widget.config(state=tk.NORMAL)
        # Clear the current content
        result_text_widget.delete('1.0', tk.END)
        # Insert the new message
        result_text_widget.insert(tk.END, msg)
        # Disable the text widget to prevent further modifications
        result_text_widget.config(state=tk.DISABLED)

# Check for evil characters in a URL
def check_EVIL(url):
    # Define a list of evil characters
    bad_chars = ['\u0430', '\u03F2', '\u0435', '\u043E', '\u0440', '\u0455', '\u0501', '\u051B', '\u051D']
    # Check if any of the evil characters are present in the URL
    result = [bad_chars[i] for i in range(len(bad_chars)) if bad_chars[i] in url]
    if result:
        msg = f'\n[*] Evil URL detected: {url}\n[*] Evil characters used: {result}\n'
    else:
        msg = f'\n[*] Valid URL detected: {url}\n'
    return msg

# Check if a URL can be connected
def check_url(url):
    try:
        # Try to resolve the URL to an IP address
        url = gethostbyname(url)
    except gaierror as err:
        # Handle error if the URL cannot be resolved
        msg = f'[*] Error: {err}\n'
        return msg

    # Create a socket and check if it can connect to the URL on port 80 (HTTP)
    s = socket(AF_INET, SOCK_STREAM)
    check = s.connect_ex((url, 80))
    if check == 0:
        msg = f'[*] Connection accepted\n'
    else:
        msg = f'[*] Connection refused\n'
    return msg

# Read a list of URLs from a file and check for evil characters in each URL
def urls_list(file):
    with open(file, encoding='utf-8') as arq:
        urls = [f.strip() for f in arq]
    result_msg = ''
    for i in range(len(urls)):
        result_msg += check_EVIL(urls[i]) + '\n'
    show_result(result_msg)

# Check a list of URLs from a file for evil characters and connection status
def check_list_url(file):
    with open(file, encoding='utf-8') as arq:
        urls_arq = [u.strip() for u in arq]
    msg = ''
    for url in urls_arq:
        bad_chars = ['\u0430', '\u03F2', '\u0435', '\u043E', '\u0440', '\u0455', '\u0501', '\u051B', '\u051D']
        result = [bad_chars[i] for i in range(len(bad_chars)) if bad_chars[i] in url]
        check_result = check_url(url)
        if result:
            msg += f'\n[*] Evil URL detected: {url}\n[*] Evil characters used: {result}\n'
            msg += check_result
        else:
            msg += f'\n[*] Valid URL detected: {url}\n'
            msg += check_result
    return msg

# Main function to create the GUI and handle user interactions
def main():
    global result_text_widget
    root = tk.Tk()
    root.title("CheckURL GUI")

    # Create and display the graphical banner
    tk.Label(root, text=banner(), justify=tk.LEFT, font=('Consolas', 12), bg='black', fg='grey').pack()

    # Create the text widget to display results
    text_frame = tk.Frame(root)
    text_frame.pack(fill=tk.BOTH, expand=True)
    v_scrollbar = tk.Scrollbar(text_frame)
    v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    h_scrollbar = tk.Scrollbar(text_frame, orient=tk.HORIZONTAL)
    h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
    global result_text_widget
    result_text_widget = tk.Text(text_frame, wrap='word', font=('Consolas', 12), bg='black', fg='white', state=tk.DISABLED,
                                 yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
    result_text_widget.pack(fill=tk.BOTH, expand=True)
    v_scrollbar.config(command=result_text_widget.yview)
    h_scrollbar.config(command=result_text_widget.xview)

    # Function to check for evil characters in a single URL
    def check_evil_url():
        url = url_entry.get().strip()
        if url:
            result_msg = check_EVIL(url)
            show_result(result_msg)
        else:
            messagebox.showwarning("Empty URL", "Please enter a URL to check.")

    # Function to check the connection to a single URL
    def check_connection():
        url = url_entry.get().strip()
        if url:
            result_msg = check_EVIL(url) + '\n' + check_url(url)
            show_result(result_msg)
        else:
            messagebox.showwarning("Empty URL", "Please enter a URL to check.")

    # Function to browse and select a file containing a list of URLs for checking
    def browse_file():
        file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
        url_list_entry.delete(0, tk.END)
        url_list_entry.insert(tk.END, file_path)

    # Function to check a list of URLs in a file for evil characters and connection status (using threading)
    def check_list_url_evil():
        file = url_list_entry.get().strip()
        if file:
            check_url_list_btn.config(state=tk.DISABLED)
            threading.Thread(target=check_list_url_with_progress, args=(file,), daemon=True).start()
        else:
            messagebox.showwarning("Empty File", "Please select a file with a list of URLs to check.")

    # Function to check a list of URLs in a file for evil characters and connection status (with progress bar)
    def check_list_url_with_progress(file):
        progress = ttk.Progressbar(root, mode='indeterminate')
        progress.pack(pady=5)
        progress.start()
        result_msg = check_list_url(file)
        progress.stop()
        progress.pack_forget()
        show_result(result_msg)
        check_url_list_btn.config(state=tk.NORMAL)

    # Create and place the URL entry and label
    url_entry_frame = tk.Frame(root)
    url_entry_frame.pack(padx=10, pady=5)
    tk.Label(url_entry_frame, text="Enter URL:").pack(side=tk.LEFT)
    url_entry = tk.Entry(url_entry_frame, width=50)
    url_entry.pack(side=tk.LEFT)
    url_entry.bind("<Control-v>", lambda event: url_entry.event_generate("<<Paste>>"))
    url_entry_context_menu = tk.Menu(root, tearoff=0)
    url_entry_context_menu.add_command(label="Cut", command=lambda: url_entry.event_generate("<<Cut>>"))
    url_entry_context_menu.add_command(label="Copy", command=lambda: url_entry.event_generate("<<Copy>>"))
    url_entry_context_menu.add_command(label="Paste", command=lambda: url_entry.event_generate("<<Paste>>"))
    def show_url_entry_context_menu(event):
        url_entry_context_menu.post(event.x_root, event.y_root)
    url_entry.bind("<Button-3>", show_url_entry_context_menu)

    # Create the "Check Evil URL" button
    check_evil_url_btn = tk.Button(root, text="Check Evil URL", command=check_evil_url)
    check_evil_url_btn.pack(padx=10, pady=5)

    # Create and place the URL check connection label and button
    check_socket_frame = tk.Frame(root)
    check_socket_frame.pack(padx=10, pady=5)
    tk.Label(check_socket_frame, text="Check Connection:").pack(side=tk.LEFT)
    check_socket_btn = tk.Button(check_socket_frame, text="Check", command=check_connection)
    check_socket_btn.pack(side=tk.LEFT)

    # Create and place the URL list file entry and browse button
    url_list_frame = tk.Frame(root)
    url_list_frame.pack(padx=10, pady=5)
    tk.Label(url_list_frame, text="URL List File:").pack(side=tk.LEFT)
    url_list_entry = tk.Entry(url_list_frame, width=50)
    url_list_entry.pack(side=tk.LEFT)
    url_list_entry.bind("<Control-v>", lambda event: url_list_entry.event_generate("<<Paste>>"))
    url_list_entry_context_menu = tk.Menu(root, tearoff=0)
    url_list_entry_context_menu.add_command(label="Cut", command=lambda: url_list_entry.event_generate("<<Cut>>"))
    url_list_entry_context_menu.add_command(label="Copy", command=lambda: url_list_entry.event_generate("<<Copy>>"))
    url_list_entry_context_menu.add_command(label="Paste", command=lambda: url_list_entry.event_generate("<<Paste>>"))
    def show_url_list_entry_context_menu(event):
        url_list_entry_context_menu.post(event.x_root, event.y_root)
    url_list_entry.bind("<Button-3>", show_url_list_entry_context_menu)

    # Create the "Browse" button to select a URL list file
    browse_btn = tk.Button(url_list_frame, text="Browse", command=browse_file)
    browse_btn.pack(side=tk.LEFT)

    # Create the "Check URLs in List" button
    check_url_list_btn = tk.Button(root, text="Check URLs in List", command=check_list_url_evil)
    check_url_list_btn.pack(padx=10, pady=5)

    # Start the main GUI event loop
    root.mainloop()

# Entry point for the script, execute the main function if this script is run directly
if __name__ == "__main__":
    main()
